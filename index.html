<html lang="en">
<head>
<meta charset="UTF--8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Kronborgs Widget</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<style>
body {
margin: 0;
padding: 0;
background: #000000;
color: white;
font-family: 'Inter', sans-serif;
}
:root {
--header-font-size: 21.2px;
--info-font-size: 20.2px;
--clock-font-size: 55px;
--weather-font-size: 20.2px;
--map-zoom-level: 1;
}
.widget {
position: fixed;
bottom: 0;
left: 0;
width: 100%;
height: 120px;
display: flex;
flex-direction: row;
align-items: flex-start;
justify-content: space-between;
background: #000000;
padding: 12px 6px;
box-sizing: border-box;
gap: 3.6px; /* Gap reduced by 10% from 4px */
}
.section {
flex: 1;
text-align: center;
padding: 0 6px;
opacity: 0;
animation: fadeIn 0.5s ease-in forwards;
}
.section h2 {
font-size: var(--header-font-size);
margin: 0 0 6px;
line-height: 24px;
color: #e5e7eb;
}
.section p {
font-size: var(--info-font-size);
margin: 2px 0;
color: #d1d5db;
}
.time-section p {
font-size: var(--clock-font-size);
color: #ffffff;
}
.weather-details {
font-size: var(--weather-font-size);
display: flex;
flex-direction: column;
justify-content: center;
}
.weather-details p {
font-size: var(--weather-font-size);
}
.map-section {
flex: 2.2;
display: flex;
justify-content: center;
}
#map {
height: 100px;
width: 70%;
border: none;
background: #000000;
overflow: hidden;
margin: 0 auto;
border-radius: 8px;
box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}
.leaflet-container {
background: #000000;
border-radius: 8px;
}
.leaflet-tile-container {
background: #000000;
}
.weather-section {
display: flex;
align-items: center;
justify-content: center;
gap: 12px;
}
.weather-icon {
width: 62.4px;
height: 62.4px;
transition: opacity 0.3s ease;
}
.nav-section {
display: flex;
flex-direction: column;
align-items: center;
}
.nav-section p {
line-height: 1.2;
}
#debug {
position: fixed;
top: 10px;
left: 10px;
color: #ef4444;
font-size: 14px;
z-index: 1000;
}
@keyframes fadeIn {
from { opacity: 0; transform: translateY(5px); }
to { opacity: 1; transform: translateY(0); }
}
@media (orientation: portrait) {
.widget {
height: 150px;
}
#map {
width: 90%;
height: 120px;
}
}
</style>
</head>
<body>
<div id="debug">Debug: Loading...</div>
<div class="widget">
<div class="section nav-section">
<h2>Navigation</h2>
<p id="course-speed">Loading...</p>
</div>
<div class="section" id="distance-section">
<h2>Distance to Destination</h2>
<p id="distance">Loading...</p>
</div>
<div class="section map-section">
<div id="map"></div>
</div>
<div class="section">
<h2>Next Destination</h2>
<p id="destination">Loading...</p>
<p id="eta">Loading...</p>
</div>
<div class="section">
<h2>Weather at Destination</h2>
<div class="weather-section">
<img class="weather-icon" id="weather-icon" src="" alt="Weather Icon">
<div class="weather-details">
<p id="weather-description">Loading...</p>
<p id="weather-temp">Loading...</p>
</div>
</div>
</div>
<div class="section time-section">
<h2>Onboard Time</h2>
<p id="current-time">Loading...</p>
</div>
</div>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script>
var map = L.map('map', {
zoomControl: false,
attributionControl: false,
renderer: L.canvas(),
maxZoom: 20
});
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
subdomains: 'abcd',
minZoom: 0,
maxZoom: 20
}).addTo(map);
const defaultIcon = L.icon({
iconUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-icon.png',
iconSize: [12, 20],
iconAnchor: [6, 20],
popupAnchor: [0, -18],
shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
shadowSize: [20, 20]
});
const shipIcon = L.icon({
iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
iconSize: [12, 20],
iconAnchor: [6, 20],
popupAnchor: [0, -18],
shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
shadowSize: [20, 20]
});
const harbourIcon = L.icon({
iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-green.png',
iconSize: [12, 20],
iconAnchor: [6, 20],
popupAnchor: [0, -18],
shadowUrl: 'https://unpkg.com/leaflet@1.7.1/dist/images/marker-shadow.png',
shadowSize: [20, 20]
});
let currentMarker = null;
let destinationMarker = null;
let routeLine = null;
let departureLine = null;
let departureMarker = null;
const destinationMap = {
'torshavn': { name: 'Tórshavn', country: 'Faroe Islands', latitude: 62.010, longitude: -6.771 },
'hirtshals': { name: 'Hirtshals', country: 'Denmark', latitude: 57.594, longitude: 9.965 },
'seydisfjord': { name: 'Seyðisfjörður', country: 'Iceland', latitude: 65.262, longitude: -14.012 }
};
const routeWaypoints = {
'torshavn-hirtshals': [
[62.010, -6.771],[61.000, -6.000],[58.000, 5.000],[57.594, 9.965]
],
'hirtshals-torshavn': [
[57.594, 9.965],[58.000, 5.000],[61.000, -6.000],[62.010, -6.771]
],
'torshavn-seydisfjord': [
[62.010, -6.771],[63.500, -10.000],[65.262, -14.012]
],
'seydisfjord-torshavn': [
[65.262, -14.012],[63.500, -10.000],[62.010, -6.771]
],
'hirtshals-seydisfjord': [
[57.594, 9.965],[61.000, 5.000],[64.000, -10.000],[65.262, -14.012]
],
'seydisfjord-hirtshals': [
[65.262, -14.012],[64.000, -10.000],[61.000, 5.000],[57.594, 9.965]
]
};
function getRouteKey(origin, destination) {
return `${origin}-${destination}`;
}
function normalizeDestinationName(name) {
if (!name) return '';
return name.toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/ð/g, 'd').replace(/[^a-z0-9]/g, '');
}
function haversineDistance(lat1, lon1, lat2, lon2) {
const R = 6371;
const dLat = (lat2 - lat1) * Math.PI / 180;
const dLon = (lon2 - lon1) * Math.PI / 180;
const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
Math.sin(dLon / 2) * Math.sin(dLon / 2);
const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
return R * c;
}
function findClosestHarbour(currentLat, currentLon, threshold = 1.5) {
let closestHarbour = null;
let minDistance = Infinity;
for (const key in destinationMap) {
const harbour = destinationMap[key];
const distance = haversineDistance(currentLat, currentLon, harbour.latitude, harbour.longitude);
if (distance < minDistance) {
minDistance = distance;
closestHarbour = { key: key, ...harbour };
}
}
if (minDistance <= threshold) {
return { ...closestHarbour, distance: minDistance };
}
return null;
}
function formatETA(eta) {
if (!eta) {
return 'N/A';
}
try {
const date = new Date(eta);
if (isNaN(date.getTime())) {
return 'N/A';
}
const now = new Date();
const prefix = date.getTime() < now.getTime() ? 'Arrived: ' : '';
const day = date.toLocaleDateString('en-GB', { weekday: 'long', timeZone: 'Atlantic/Faroe' });
const time = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Atlantic/Faroe' });
return `${prefix}${day}, ${time}`;
} catch (error) {
return 'N/A';
}
}
function formatTravelTime(distance, speedKnots) {
if (speedKnots === 0) return 'N/A';
const speedKmh = speedKnots * 1.852;
const hours = distance / speedKmh;
if (isNaN(hours) || hours < 0) return 'N/A';
const days = Math.floor(hours / 24);
const remainingHours = Math.floor(hours % 24);
const minutes = Math.round((hours % 1) * 60);
let timeString = '';
if (days > 0) timeString += `${days}d `;
if (remainingHours > 0 || days > 0) timeString += `${remainingHours}h `;
timeString += `${minutes}m`;
return timeString.trim();
}
const conditionMap = {
'CLEAR': { description: 'Clear', icon: '01d' }, 'CLEAR_DAY': { description: 'Clear', icon: '01d' }, 'CLEAR_NIGHT': { description: 'Clear', icon: '01n' }, 'CLOUDY': { description: 'Cloudy', icon: '04d' }, 'CLOUDY_DAY': { description: 'Cloudy', icon: '04d' }, 'CLOUDY_NIGHT': { description: 'Cloudy', icon: '04n' }, 'PARTLY_CLOUDY': { description: 'Partly Cloudy', icon: '03d' }, 'PARTLY_CLOUDY_DAY': { description: 'Partly Cloudy', icon: '03d' }, 'PARTLY_CLOUDY_NIGHT': { description: 'Partly Cloudy', icon: '03n' }, 'MOSTLY_CLOUDY': { description: 'Mostly Cloudy', icon: '04d' }, 'MOSTLY_CLOUDY_DAY': { description: 'Mostly Cloudy', icon: '04d' }, 'MOSTLY_CLOUDY_NIGHT': { description: 'Mostly Cloudy', icon: '04n' }, 'OVERCAST': { description: 'Overcast', icon: '04d' }, 'FOG': { description: 'Fog', icon: '50d' }, 'HAZE': { description: 'Haze', icon: '50d' }, 'MIST': { description: 'Mist', icon: '50d' }, 'SMOKE': { description: 'Smoke', icon: '50d' }, 'DUST': { description: 'Dust', icon: '50d' }, 'LIGHT_RAIN': { description: 'Light Rain', icon: '10d' }, 'RAIN': { description: 'Rain', icon: '10d' }, 'RAIN_DAY': { description: 'Rain', icon: '10d' }, 'RAIN_NIGHT': { description: 'Rain', icon: '10n' }, 'HEAVY_RAIN': { description: 'Heavy Rain', icon: '10d' }, 'SHOWERS': { description: 'Showers', icon: '09d' }, 'SCATTERED_SHOWERS': { description: 'Scattered Showers', icon: '09d' }, 'RAIN_SHOWERS': { description: 'Rain Showers', icon: '09d' }, 'THUNDERSTORM': { description: 'Thunderstorm', icon: '11d' }, 'SCATTERED_THUNDERSTORMS': { description: 'Scattered Thunderstorms', icon: '11d' }, 'CHANCE_OF_RAIN': { description: 'Chance of Rain', icon: '10d' }, 'CHANCE_OF_STORM': { description: 'Chance of Storm', icon: '11d' }, 'SNOW': { description: 'Snow', icon: '13d' }, 'SNOW_DAY': { description: 'Snow', icon: '13d' }, 'SNOW_NIGHT': { description: 'Snow', icon: '13n' }, 'SNOW_SHOWERS': { description: 'Snow Showers', icon: '13d' }, 'CHANCE_OF_SNOW': { description: 'Chance of Snow', icon: '13d' }, 'FLURRIES': { description: 'Flurries', icon: '13d' }, 'SLEET': { description: 'Sleet', icon: '13d' }, 'ICY': { description: 'Icy', icon: '13d' }, 'SUNNY': { description: 'Sunny', icon: '01d' }, 'MOSTLY_SUNNY': { description: 'Mostly Sunny', icon: '02d' }, 'PARTLY_SUNNY': { description: 'Partly Sunny', icon: '03d' }, 'STORM': { description: 'Storm', icon: '11d' }, 'UNKNOWN': { description: 'Unknown', icon: '04d' }
};
function getWeatherCacheKey(lat, lon) {
const roundedLat = Number(lat).toFixed(3); const roundedLon = Number(lon).toFixed(3); return `weather_${roundedLat}_${roundedLon}`;
}
function loadCachedWeather(lat, lon) {
const cacheKey = getWeatherCacheKey(lat, lon); const cached = localStorage.getItem(cacheKey); if (cached) { try { const data = JSON.parse(cached); const cacheTime = data.timestamp || 0; const now = Date.now(); if (data.description === 'Unknown' || data.temp === 0) { localStorage.removeItem(cacheKey); return null; } if (now - cacheTime < 30 * 60 * 1000) { return data; } else { localStorage.removeItem(cacheKey); return null; } } catch (e) { localStorage.removeItem(cacheKey); return null; } } return null;
}
function saveCachedWeather(lat, lon, weatherData) {
const cacheKey = getWeatherCacheKey(lat, lon); try { weatherData.timestamp = Date.now(); localStorage.setItem(cacheKey, JSON.stringify(weatherData)); } catch (e) { console.error('Error saving cached weather data:', e.message); }
}
function displayCachedWeather(cachedWeather) {
if (!cachedWeather) return false; document.getElementById('weather-description').textContent = cachedWeather.description; document.getElementById('weather-temp').textContent = `${cachedWeather.temp}°C`; document.getElementById('weather-icon').src = cachedWeather.iconSrc; document.getElementById('weather-icon').alt = cachedWeather.description; return true;
}
async function fetchWeather(lat, lon) {
const cachedWeather = loadCachedWeather(lat, lon); if (cachedWeather) { displayCachedWeather(cachedWeather); return; } try { const apiKey = 'AIzaSyAAXsfnLWGjbcz4RGlERJwo3Y0Soe56ryI'; const url = `https://weather.googleapis.com/v1/currentConditions:lookup?key=${apiKey}&location.latitude=${lat}&location.longitude=${lon}`; const response = await fetch(url, { cache: 'no-store' }); if (!response.ok) { throw new Error(`Weather API response not OK: ${response.status}`); } const data = await response.json(); if (!data.weatherCondition || !data.temperature || typeof data.temperature.degrees !== 'number') { throw new Error('Invalid API response'); } const conditionType = data.weatherCondition.type?.toUpperCase() || 'UNKNOWN'; const conditionText = data.weatherCondition.description?.text || conditionMap[conditionType]?.description || 'Unknown'; const condition = conditionMap[conditionType] || conditionMap['UNKNOWN']; const temp = data.temperature.degrees ?? 0; const description = conditionText; const icon = condition.icon; const iconSrc = `https://openweathermap.org/img/wn/${icon}@2x.png`; document.getElementById('weather-description').textContent = description; document.getElementById('weather-temp').textContent = `${Math.round(temp)}°C`; document.getElementById('weather-icon').src = iconSrc; document.getElementById('weather-icon').alt = description; saveCachedWeather(lat, lon, { description, temp, iconSrc }); } catch (error) { console.error(`Error fetching weather for ${lat},${lon}:`, error.message); if (!displayCachedWeather(loadCachedWeather(lat, lon))) { document.getElementById('weather-description').textContent = 'N/A'; document.getElementById('weather-temp').textContent = 'N/A'; document.getElementById('weather-icon').src = ''; document.getElementById('weather-icon').alt = 'N/A'; } }
}
function loadCachedData() {
const cached = localStorage.getItem('shipData'); if (cached) { try { const data = JSON.parse(cached); const cacheTime = data.timestamp || 0; if (Date.now() - cacheTime < 15 * 60 * 1000) { return data; } } catch (e) { /* ignore */ } } return null;
}
function saveCachedData(data) {
try { data.timestamp = Date.now(); localStorage.setItem('shipData', JSON.stringify(data)); } catch (e) { console.error('Error saving cached ship data:', e.message); }
}
function displayCachedData(cachedData) {
if (!cachedData) return;
document.getElementById('course-speed').innerHTML = cachedData.courseSpeed || 'N/A';
document.getElementById('distance').textContent = cachedData.distance || 'N/A';
document.getElementById('destination').textContent = cachedData.destination || 'N/A';
document.getElementById('eta').textContent = cachedData.eta || 'N/A';
const clearMapLayers = () => {
if (currentMarker) { map.removeLayer(currentMarker); currentMarker = null; }
if (destinationMarker) { map.removeLayer(destinationMarker); destinationMarker = null; }
if (departureMarker) { map.removeLayer(departureMarker); departureMarker = null; }
if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
if (departureLine) { map.removeLayer(departureLine); departureLine = null; }
};
clearMapLayers();
if (cachedData.isInHarbour && cachedData.harbourMarker) {
currentMarker = L.marker(cachedData.harbourMarker.latLng, { icon: harbourIcon }).addTo(map).bindPopup(cachedData.harbourMarker.popup);
map.setView(cachedData.harbourMarker.latLng, 20);
} else if (cachedData.currentMarker) {
currentMarker = L.marker(cachedData.currentMarker.latLng, { icon: shipIcon }).addTo(map).bindPopup('<b>Norröna (Current Position)</b><br>(Cached)');
if (cachedData.destinationMarker) {
destinationMarker = L.marker(cachedData.destinationMarker.latLng, { icon: defaultIcon }).addTo(map).bindPopup(`<b>${cachedData.destination}</b><br>(Destination, Cached)`);
}
if (cachedData.departureMarker) {
departureMarker = L.marker(cachedData.departureMarker.latLng, { icon: defaultIcon }).addTo(map).bindPopup(`<b>${cachedData.departureName}</b><br>(Departure, Cached)`);
}
if (cachedData.currentMarker && cachedData.destinationMarker && cachedData.departureMarker && cachedData.departureName) {
const routeKey = getRouteKey(normalizeDestinationName(cachedData.departureName.split(',')[0]), normalizeDestinationName(cachedData.destination.split(',')[0]));
const waypoints = routeWaypoints[routeKey] || [cachedData.departureMarker.latLng, cachedData.currentMarker.latLng, cachedData.destinationMarker.latLng];
const waypointsWithCurrent = [waypoints[0], cachedData.currentMarker.latLng, ...waypoints.slice(1)];
departureLine = L.polyline([waypointsWithCurrent[0], waypointsWithCurrent[1]], { color: '#808080', weight: 2 }).addTo(map);
routeLine = L.polyline(waypointsWithCurrent.slice(1), { color: '#FFFFFF', weight: 2, dashArray: '5, 5' }).addTo(map);
const bounds = L.latLngBounds([cachedData.currentMarker.latLng, cachedData.destinationMarker.latLng, cachedData.departureMarker.latLng]);
map.fitBounds(bounds, { padding: [10, 10] });
}
}
}
function calculateZoomLevel(distance) {
if (distance > 100) return 5; if (distance <= 1) return 18; return Math.round(5 + (18 - 5) * (100 - distance) / (100 - 1));
}
async function updateShipData(attempt = 1, maxAttempts = 5) {
const debug = document.getElementById('debug');
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 15000);
try {
debug.textContent = `Debug: Fetching API (Attempt ${attempt}/${maxAttempts})`;
const response = await fetch('https://smyrillinewebapi-cec3fkhjh8bbhtd3.northeurope-01.azurewebsites.net/vessel/vessels', { cache: 'no-store', signal: controller.signal });
clearTimeout(timeoutId);
if (!response.ok) throw new Error(`Vessel API response not OK: ${response.status}`);
const data = await response.json();
if (!data || !Array.isArray(data) || data.length === 0) throw new Error('API returned empty or invalid data');
const norrona = data.find(vessel => vessel.vesselName?.toUpperCase() === 'NORRONA');
if (!norrona || !norrona.position || !norrona.destinationFromAIS) throw new Error('Norröna data incomplete');
debug.textContent = 'Debug: API Success';
const { latitude, longitude, speed, course } = norrona.position;
const speedKnots = speed || 0;
const speedKmh = (speedKnots * 1.852).toFixed(1);

const courseSpeedText = `${(course || 0).toFixed(1)}°<br>${speedKnots.toFixed(1)} kn / ${speedKmh} km/h`;

document.getElementById('course-speed').innerHTML = courseSpeedText;
const destNameNormalized = normalizeDestinationName(norrona.destinationFromAIS.split(',')[0]);
const destInfo = destinationMap[destNameNormalized];
if (!destInfo) throw new Error(`Destination ${destNameNormalized} not found`);
const displayName = `${destInfo.name}, ${destInfo.country}`;
document.getElementById('destination').textContent = displayName;
document.getElementById('eta').textContent = formatETA(norrona.etaFromAIS);
const clearMapLayers = () => {
if (currentMarker) map.removeLayer(currentMarker); if (destinationMarker) map.removeLayer(destinationMarker); if (departureMarker) map.removeLayer(departureMarker); if (routeLine) map.removeLayer(routeLine); if (departureLine) map.removeLayer(departureLine);
currentMarker = destinationMarker = departureMarker = routeLine = departureLine = null;
};
clearMapLayers();
const currentHarbour = findClosestHarbour(latitude, longitude);
const isInHarbour = currentHarbour && speedKnots < 1;
let newCachedData = {};
if (isInHarbour) {
document.getElementById('distance').textContent = `In Harbour at ${currentHarbour.name}`;
map.setView([latitude, longitude], 20);
currentMarker = L.marker([latitude, longitude], { icon: harbourIcon }).addTo(map).bindPopup(`<b>In Harbour</b><br>${currentHarbour.name}`);

localStorage.setItem('lastKnownPort', currentHarbour.key);

newCachedData = {
isInHarbour: true,
distance: `In Harbour at ${currentHarbour.name}`,
harbourMarker: { latLng: [latitude, longitude], popup: `<b>In Harbour</b><br>${currentHarbour.name}` }
};
} else {
const distanceToDest = haversineDistance(latitude, longitude, destInfo.latitude, destInfo.longitude);
document.getElementById('distance').textContent = `~${Math.round(distanceToDest)} km / ${formatTravelTime(distanceToDest, speedKnots)}`;

const departureInfoKey = localStorage.getItem('lastKnownPort') || 'hirtshals';
const departureInfo = destinationMap[departureInfoKey];
if (!departureInfo) throw new Error(`Departure port ${departureInfoKey} not found`);

currentMarker = L.marker([latitude, longitude], { icon: shipIcon }).addTo(map).bindPopup('<b>Norröna (Current Position)</b>');
destinationMarker = L.marker([destInfo.latitude, destInfo.longitude], { icon: defaultIcon }).addTo(map).bindPopup(`<b>${displayName}</b><br>Destination`);
departureMarker = L.marker([departureInfo.latitude, departureInfo.longitude], { icon: defaultIcon }).addTo(map).bindPopup(`<b>${departureInfo.name}</b><br>Departure`);

const routeKey = getRouteKey(departureInfoKey, destNameNormalized);
const waypoints = routeWaypoints[routeKey] || [[departureInfo.latitude, departureInfo.longitude], [latitude, longitude], [destInfo.latitude, destInfo.longitude]];
const waypointsWithCurrent = [waypoints[0], [latitude, longitude], ...waypoints.slice(1)];
departureLine = L.polyline([waypointsWithCurrent[0], waypointsWithCurrent[1]], { color: '#808080', weight: 2 }).addTo(map);
routeLine = L.polyline(waypointsWithCurrent.slice(1), { color: '#FFFFFF', weight: 2, dashArray: '5, 5' }).addTo(map);

const bounds = L.latLngBounds([[latitude, longitude], [destInfo.latitude, destInfo.longitude], [departureInfo.latitude, departureInfo.longitude]]);
map.fitBounds(bounds, { padding: [10, 10], maxZoom: calculateZoomLevel(distanceToDest) });

newCachedData = {
isInHarbour: false,
distance: `~${Math.round(distanceToDest)} km / ${formatTravelTime(distanceToDest, speedKnots)}`,
currentMarker: { latLng: [latitude, longitude] },
destinationMarker: { latLng: [destInfo.latitude, destInfo.longitude] },
departureMarker: { latLng: [departureInfo.latitude, departureInfo.longitude] },
departureName: departureInfo.name
};
}
saveCachedData({
...newCachedData,
courseSpeed: courseSpeedText,
destination: displayName,
eta: formatETA(norrona.etaFromAIS)
});
await fetchWeather(destInfo.latitude, destInfo.longitude);
} catch (error) {
const errorMessage = error.message || 'Unknown error';
debug.textContent = `Debug: Error - ${errorMessage} (Attempt ${attempt}/${maxAttempts})`;
if (attempt < maxAttempts) {
const delay = 30000 * attempt;
debug.textContent += ` | Retrying in ${delay / 1000}s`;
await new Promise(resolve => setTimeout(resolve, delay));
return updateShipData(attempt + 1, maxAttempts);
}
const cachedData = loadCachedData();
if (cachedData) {
debug.textContent += ' | Using cached data';
displayCachedData(cachedData);
} else {
debug.textContent += ' | No cached data available';
}
}
}
function updateTime() {
const now = new Date();
const options = { timeZone: 'Atlantic/Faroe', hour: '2-digit', minute: '2-digit', hour12: false };
document.getElementById('current-time').textContent = now.toLocaleTimeString('en-GB', options);
}
const cachedData = loadCachedData();
if (cachedData) {
document.getElementById('debug').textContent = 'Debug: Loading cached data';
displayCachedData(cachedData);
if (cachedData.destinationMarker) {
fetchWeather(cachedData.destinationMarker.latLng[0], cachedData.destinationMarker.latLng[1]);
} else if (cachedData.harbourMarker) {
fetchWeather(cachedData.harbourMarker.latLng[0], cachedData.harbourMarker.latLng[1]);
}
}
updateTime();
updateShipData();
setInterval(updateTime, 1000);
setInterval(updateShipData, 120000);
</script>
</body>
</html>
